[{"title":"test","url":"/2025/03/18/test/","content":"\nhsjdfhjkshfjk\n"},{"title":"[GO]设计模式","url":"/2025/03/09/GO-设计模式/","content":"[mode](https://blog.csdn.net/qq_18237141/article/details/130520950?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522915009a2364cbc335e4132d5d4ca40a0%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=915009a2364cbc335e4132d5d4ca40a0&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-130520950-null-null.142^v102^pc_search_result_base4&utm_term=go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)","tags":["设计模式"],"categories":["GO"]},{"title":"[GO]协程","url":"/2025/02/24/GO-协程/","content":"\n## MPG模型：\n\ngo语言中的MPG模式是一种特殊的两级线程模型，将CPU，内核线程，用户线程之间的管理，描述为M,P,G三者的关系。\n\n- M：machine。一个M对应一个内核级线程，相当于内核级线程在go中的映射。\n- P：processor。go语言代码所需要上下文环境。\n- G：goroutine。用户级线程。\n","tags":["并发"],"categories":["GO"]},{"title":"[GO]sync包","url":"/2025/02/23/GO-sync包/","content":"\n# sync包\n\n## sync包工具：\n\n\t1. 互斥锁：Mutex\n\t2. 读写锁：RWMutex\n\t3. 等待组： WaitGroup\n\t4. 并发安全字典：Map\n\t5. 单例模式：Once\n\n\n\n### Mutex:\n\n- 保证在同一时间只有一个goroutine持有锁\n- 保证了在这一时间段内只有这以一个goroutine可以访问共享资源,其他goroutine会被堵塞直到锁被释放\n\n\n\n### RWMutex：\n\n- 在同一时间只有一个goroutine获得WLock\n- 在同一时间可以有多个goroutine获得RLock\n- 在同一时间只能存在写锁hi哦这读锁，即读写锁互斥\n``` go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar p = fmt.Println\n\nfunc main() {\n\tp(\"main func starts\")\n\tvar lock sync.RWMutex\n\t// GOTIME := \"2025-1-2 15:04:23\"\n\n\tp(\"start rlock at: \", time.Now())\n\tfor i := range 5 {\n\t\tgo func(i int) {\n\t\t\tdefer lock.RUnlock()\n\t\t\tlock.RLock()\n\t\t\tp(\"func\", i, \"gets rlock at: \", time.Now())\n\t\t\ttime.Sleep(time.Second)\n\t\t\tp(\"func\", i, \"release rlock at: \", time.Now())\n\t\t}(i)\n\t}\n\ttime.Sleep(time.Second / 10)\n\n\tp(\"============================================\")\n\tp(\"start wlock at:\", time.Now())\n\tfor i := range 5 {\n\t\tgo func(i int) {\n\t\t\tdefer lock.Unlock()\n\t\t\tlock.Lock()\n\t\t\tp(\"func\", i, \"gets wlock at: \", time.Now())\n\t\t\ttime.Sleep(time.Second)\n\t\t\tp(\"func\", i, \"release wlock at: \", time.Now())\n\t\t}(i)\n\t}\n\ttime.Sleep(10 * time.Second)\n\n\tp(\"main func is done\")\n}\n```\n---\n\n``` output\nmain func starts\nstart rlock at:  2025-02-23 20:31:33.9404441 +0800 CST m=+0.000566301\nfunc 4 gets rlock at:  2025-02-23 20:31:33.953563 +0800 CST m=+0.013685201\nfunc 1 gets rlock at:  2025-02-23 20:31:33.953563 +0800 CST m=+0.013685201\nfunc 0 gets rlock at:  2025-02-23 20:31:33.953563 +0800 CST m=+0.013685201\nfunc 3 gets rlock at:  2025-02-23 20:31:33.953563 +0800 CST m=+0.013685201\nfunc 2 gets rlock at:  2025-02-23 20:31:33.953563 +0800 CST m=+0.013685201\n============================================\nstart wlock at: 2025-02-23 20:31:34.0541687 +0800 CST m=+0.114290901\nfunc 4 release rlock at:  2025-02-23 20:31:34.9540295 +0800 CST m=+1.014151701\nfunc 1 release rlock at:  2025-02-23 20:31:34.9540295 +0800 CST m=+1.014151701\nfunc 2 release rlock at:  2025-02-23 20:31:34.954599 +0800 CST m=+1.014721201\nfunc 3 release rlock at:  2025-02-23 20:31:34.954599 +0800 CST m=+1.014721201\nfunc 0 release rlock at:  2025-02-23 20:31:34.954599 +0800 CST m=+1.014721201\nfunc 4 gets wlock at:  2025-02-23 20:31:34.9555688 +0800 CST m=+1.015691001\nfunc 4 release wlock at:  2025-02-23 20:31:35.9565869 +0800 CST m=+2.016709101\nfunc 0 gets wlock at:  2025-02-23 20:31:35.956899 +0800 CST m=+2.017021201\nfunc 0 release wlock at:  2025-02-23 20:31:36.957694 +0800 CST m=+3.017816201\nfunc 1 gets wlock at:  2025-02-23 20:31:36.9583138 +0800 CST m=+3.018436001\nfunc 1 release wlock at:  2025-02-23 20:31:37.9589584 +0800 CST m=+4.019080601\nfunc 2 gets wlock at:  2025-02-23 20:31:37.9596494 +0800 CST m=+4.019771601\nfunc 2 release wlock at:  2025-02-23 20:31:38.9608447 +0800 CST m=+5.020966901\nfunc 3 gets wlock at:  2025-02-23 20:31:38.961154 +0800 CST m=+5.021276201\nfunc 3 release wlock at:  2025-02-23 20:31:39.96198 +0800 CST m=+6.022102201\nmain func is done\n```\n\n\n\n### Map:\n\n- go原生中的map不是并发安全的，当多个goroutine同时往map中添加数据时，可能会导致部分数据丢失\n- 在同一个Map中可以存储多个不同类型的KV对\n\n**map中的方法：**\n\n1. func  (m *Map) **Load**(key any)(value any, ok bool)\n\n   由k获得value（相当于get）\n\n2. func (m *Map) **Store**(key, value any)\n\n   存储（set）\n\n3. func (m *Map)**LoadOrStore**(key, value any) (actual any, loaded bool)\n\n   如果key存在，返回对应的value，否则存储\n\n4. func (m *Map) **Delete**(key any)\n\n   删除一个key\n\n5. func (m *Map) **Range**(f func(key, value any),bool)\n\n   无序遍历map \n\n- 参数 f 是一个回调函数，它接收两个 interface{} 类型的参数 key 和 value，分别表示当前遍历到的键和值。\n- 回调函数返回一个 bool 类型的值，如果返回 true，则继续遍历下一个键值对；如果返回 false，则停止遍历。\n\n``` go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar p = fmt.Println\n\nfunc main() {\n\tvar dict sync.Map\n\tvar wg sync.WaitGroup\n\n\tfor i := range 10 {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tdict.Store(i, fmt.Sprintf(\"#stored %d#\", i))\n\n\t\t}(i)\n\t}\n\twg.Wait()\n\tv, ok := dict.Load(1)\n\tp(v, ok) //#stored 1# true\n\n\tdict.Store(100, \"#test100#\")\n\n\tdict.LoadOrStore(10, \"#test#\")\n\tp(dict.Load(10)) //#test# true\n\n\tv, loaded := dict.LoadAndDelete(9)\n\tp(v, loaded)    //#stored 9# true\n\tp(dict.Load(9)) //<nil> false\n\n\tp(\"===========================================\")\n\tdict.Range(func(key, value any) bool {\n\t\tk := key.(int)\n\t\tv := value.(string)\n\t\tp(\"Key: %s, Value: %d\\n\", k, v)\n\t\treturn true\n\t})\n}\n\n```\n\n","tags":["并发"],"categories":["GO"]},{"title":"[AI]学习路径","url":"/2025/02/03/AI-学习路径/","content":"\n[STEP](https://blog.csdn.net/Antai_ZHU/article/details/121540940?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522bdbcdfa210f48b0d55fbca7ec63889fb%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=bdbcdfa210f48b0d55fbca7ec63889fb&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121540940-null-null.142^v101^pc_search_result_base4&utm_term=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD&spm=1018.2226.3001.4187)\n"},{"title":"[GO]make与new","url":"/2025/02/03/GO-make与new/","tags":["GO"],"categories":["GO"]},{"title":"[GO]深拷贝与浅拷贝","url":"/2025/02/03/GO-深拷贝与浅拷贝/","content":"\n## 深浅拷贝：\n\n\n\n#### 在 go 语言中 **值类型** 赋值都是 **深拷贝**，**引用类型** 一般都是 **浅拷贝**。\n\n---\n\n#### 深拷贝：两者结果互不影响\n\n#### 浅拷贝： 两者结果相互影响，改变其中一个，另一个他跟着发生改变\n\n---\n\n### 深拷贝：\n\n深拷贝会递归地复制对象及其所有嵌套的引用类型字段，创建一个完全独立的新对象，新对象和原对象不共享任何底层数据。对新对象的任何修改都不会影响原对象，反之亦然。\n\n``` go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar a = 123\n\tb := a\t\t\t//值的拷贝，深拷贝\n\tfmt.Println(a, b)\t\t\t//123 123\n\ta = 456\n\tfmt.Println(a, b)\t\t\t// 456 123\n}\n```\n\n### 浅拷贝：\n\n浅拷贝只复制对象本身以及对象中值类型的字段，但对于引用类型的字段（如切片、映射、指针等），浅拷贝只是复制引用，而不是复制引用指向的实际数据。\n\n如下，a、b 两个 slice 指向同一个内存地址，slice 拷贝是浅拷贝。本质是因为 slice 属于 Go 的引用类型。\n\n``` go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\ta := []int{1, 2, 3}\n\tb := a //地址的拷贝，浅拷贝\n\tfmt.Println(a, b)\t\t\t// 1 2 3  1 2 3\n\n\ta[0] = 1000\n\tfmt.Println(a, b)\t\t\t// 1000 2 3  1000 2 3\n\n\tb[2] = 4000\n\tfmt.Println(a, b)\t\t\t// 1000 2 4000  1000 2 4000\n}\n```\n\n\n\n## 总结：\n\n使用  **:=**  进行拷贝时所产生的深浅拷贝问题取决于被拷贝数据的数据类型（值类型，引用类型）\n\n- **值类型：深拷贝**\n\n  ​\t**值类型：** int、float、bool 和 string ，除此之外，数组和结构体这两个聚合类型也是**值类型**。\n\n- **引用类型：浅拷贝**\n\n​\t\t **引用类型：**指针、切片、map、函数、channel。\n","tags":["GO","杂谈"],"categories":["GO"]},{"title":"[GO]\"...\"的用法","url":"/2025/02/03/GO-的用法/","content":"## 1.在定义数组[...]时的数组容量处的...表示由编译器自动计算数组元素大小\n\n``` go\n// 数组定义 这个是手动指定数组大小\narr1 := [2]string{\"Hello\", \" World\"}\n// 由编译器自动计算数组元素，这个和上面的效果一样\narr2 := [...]string{\"Hello\", \" World\"}\n```\n\n\n\n## 2. 用在append函数的第二个参数后面时，append(a, b...) 表示增加b中所有的数据到a中,append函数原型 func append(s []T, x ...T) []T \n\n```go\na := []string{\"John\", \"Paul\"}\nb := []string{\"George\", \"Ringo\", \"Pete\"}\na = append(a, b...) // \tequivalent to \"append(a, b[0], b[1], b[2])\"\nfmt.Println(a)\t\t//\t[John Paul George Ringo Pete]\n```\n\n\n\n## 3. 用在函数形参中时表示可变参数\n\n``` go\npackage main\n \nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n// 可变参数函数\nfunc Fullname(names ...string) string {\n  return strings.Join(names, \" \")\n}\nfunc main() {\n\tfn1 := Fullname(\"Tekin\", \"Tian\")\n\tfmt.Println(\"fn1=\", fn1) // fn1= Tekin Tian\n \n \n\tfn2 :=Fullname(\"Tekin\")\n\tfmt.Println(\"fn2=\", fn2) // fn2= Tekin\n \n\tfn3 :=Fullname()\n\tfmt.Println(\"fn3=\", fn3) // fn3=\n}\n```\n\n\n\n## 4. 用在带有可变参数的函数的二次封装时再次调用函数时表示解构参数\n\n``` go\npackage main\n\nimport \"fmt\"\n\n// sum 函数接受可变数量的 int 类型参数\nfunc sum(nums ...int) int {\n    total := 0\n    for _, num := range nums {\n        total += num\n    }\n    return total\n}\n\n// sumWrapper 是对 sum 函数的二次封装\nfunc sumWrapper(nums ...int) int {\n    // 对传入的 nums 参数进行处理，这里简单地直接调用 sum 函数\n    return sum(nums...)\n}\n\nfunc main() {\n    result := sumWrapper(1, 2, 3, 4)\n    fmt.Println(result) // 输出 10\n}\n```\n\n- ... 解构参数时，要求传递的必须是切片类型。\n\n","tags":["GO"],"categories":["GO"]},{"title":"Hello World","url":"/2025/01/29/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"categories","url":"/categories/index-1.html"},{"title":"tags","url":"/tags/index.html"},{"title":"categories","url":"/categories/index.html"}]